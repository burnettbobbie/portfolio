import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-use-scroll-snap/index.js
var import_react = __toESM(require_react());

// node_modules/tweezer.js/dist/tweezer.module.js
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var SingleTweener = function() {
  function SingleTweener2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, SingleTweener2);
    this.start = opts.start;
    this.end = opts.end;
    this.decimal = opts.decimal;
  }
  _createClass(SingleTweener2, [{
    key: "getIntermediateValue",
    value: function getIntermediateValue(tick) {
      if (this.decimal) {
        return tick;
      } else {
        return Math.round(tick);
      }
    }
  }, {
    key: "getFinalValue",
    value: function getFinalValue() {
      return this.end;
    }
  }]);
  return SingleTweener2;
}();
var _createClass$1 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Tweezer = function() {
  function Tweezer2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$1(this, Tweezer2);
    this.duration = opts.duration || 1e3;
    this.ease = opts.easing || this._defaultEase;
    this.tweener = opts.tweener || new SingleTweener(opts);
    this.start = this.tweener.start;
    this.end = this.tweener.end;
    this.frame = null;
    this.next = null;
    this.isRunning = false;
    this.events = {};
    this.direction = this.start < this.end ? "up" : "down";
  }
  _createClass$1(Tweezer2, [{
    key: "begin",
    value: function begin() {
      if (!this.isRunning && this.next !== this.end) {
        this.frame = window.requestAnimationFrame(this._tick.bind(this));
      }
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      window.cancelAnimationFrame(this.frame);
      this.isRunning = false;
      this.frame = null;
      this.timeStart = null;
      this.next = null;
      return this;
    }
  }, {
    key: "on",
    value: function on(name, handler) {
      this.events[name] = this.events[name] || [];
      this.events[name].push(handler);
      return this;
    }
  }, {
    key: "_emit",
    value: function _emit(name, val) {
      var _this = this;
      var e = this.events[name];
      e && e.forEach(function(handler) {
        return handler.call(_this, val);
      });
    }
  }, {
    key: "_tick",
    value: function _tick(currentTime) {
      this.isRunning = true;
      var lastTick = this.next || this.start;
      if (!this.timeStart)
        this.timeStart = currentTime;
      this.timeElapsed = currentTime - this.timeStart;
      this.next = this.ease(this.timeElapsed, this.start, this.end - this.start, this.duration);
      if (this._shouldTick(lastTick)) {
        this._emit("tick", this.tweener.getIntermediateValue(this.next));
        this.frame = window.requestAnimationFrame(this._tick.bind(this));
      } else {
        this._emit("tick", this.tweener.getFinalValue());
        this._emit("done", null);
      }
    }
  }, {
    key: "_shouldTick",
    value: function _shouldTick(lastTick) {
      return {
        up: this.next < this.end && lastTick <= this.next,
        down: this.next > this.end && lastTick >= this.next
      }[this.direction];
    }
  }, {
    key: "_defaultEase",
    value: function _defaultEase(t, b, c, d) {
      if ((t /= d / 2) < 1)
        return c / 2 * t * t + b;
      return -c / 2 * (--t * (t - 2) - 1) + b;
    }
  }]);
  return Tweezer2;
}();
var tweezer_module_default = Tweezer;

// node_modules/react-use-scroll-snap/index.js
function useScrollSnap({ ref = null, duration = 100, delay = 50 }) {
  const isActiveInteractionRef = (0, import_react.useRef)(null);
  const scrollTimeoutRef = (0, import_react.useRef)(null);
  const currentScrollOffsetRef = (0, import_react.useRef)(null);
  const targetScrollOffsetRef = (0, import_react.useRef)(null);
  const animationRef = (0, import_react.useRef)(null);
  const [scrollIndex, setScrollIndex] = (0, import_react.useState)(0);
  const tickAnimation = (0, import_react.useCallback)((value) => {
    const scrollTopDelta = targetScrollOffsetRef.current - currentScrollOffsetRef.current;
    const scrollTop = currentScrollOffsetRef.current + scrollTopDelta * value / 1e4;
    window.scrollTo({ top: scrollTop, behavior: "smooth" });
  }, []);
  const resetAnimation = (0, import_react.useCallback)(() => {
    currentScrollOffsetRef.current = window.pageYOffset;
    targetScrollOffsetRef.current = 0;
    animationRef.current = null;
  }, []);
  const endAnimation = (0, import_react.useCallback)(() => {
    if (!animationRef.current)
      return;
    animationRef.current.stop();
    resetAnimation();
  }, [resetAnimation]);
  const getElementsInView = (0, import_react.useCallback)(() => {
    const elements = [].slice.call(ref.current.children);
    return elements.filter((element) => {
      let top = element.offsetTop;
      const height = element.offsetHeight;
      while (element.offsetParent) {
        element = element.offsetParent;
        top += element.offsetTop;
      }
      return top < window.pageYOffset + window.innerHeight && top + height > window.pageYOffset;
    });
  }, [ref]);
  const getTargetScrollOffset = (0, import_react.useCallback)((element) => {
    let top = element.offsetTop;
    while (element.offsetParent) {
      element = element.offsetParent;
      top += element.offsetTop;
    }
    return top;
  }, []);
  const snapToTarget = (0, import_react.useCallback)((target) => {
    if (animationRef.current) {
      animationRef.current.stop();
    }
    const elements = [].slice.call(ref.current.children);
    elements.forEach((element, index) => {
      if (element.isSameNode(target)) {
        setScrollIndex(index);
      }
    });
    targetScrollOffsetRef.current = getTargetScrollOffset(target);
    animationRef.current = new tweezer_module_default({
      start: 0,
      end: 1e4,
      duration
    });
    animationRef.current.on("tick", tickAnimation);
    animationRef.current.on("done", resetAnimation);
    animationRef.current.begin();
  }, [ref, duration, getTargetScrollOffset, tickAnimation, resetAnimation]);
  const findSnapTarget = (0, import_react.useCallback)(() => {
    const deltaY = window.pageYOffset - currentScrollOffsetRef.current;
    currentScrollOffsetRef.current = window.pageYOffset;
    const elementsInView = getElementsInView();
    if (!elementsInView || elementsInView.length < 2)
      return;
    if (deltaY > 0) {
      snapToTarget(elementsInView[1]);
    } else {
      snapToTarget(elementsInView[0]);
    }
  }, [getElementsInView, snapToTarget]);
  const onInteractionStart = (0, import_react.useCallback)(() => {
    endAnimation();
    isActiveInteractionRef.current = true;
  }, [endAnimation]);
  const onInteractionEnd = (0, import_react.useCallback)(() => {
    isActiveInteractionRef.current = false;
    findSnapTarget();
  }, [findSnapTarget]);
  const onInteraction = (0, import_react.useCallback)(() => {
    endAnimation();
    if (scrollTimeoutRef)
      clearTimeout(scrollTimeoutRef.current);
    if (isActiveInteractionRef.current || animationRef.current)
      return;
    scrollTimeoutRef.current = setTimeout(findSnapTarget, 500);
  }, [endAnimation, findSnapTarget]);
  (0, import_react.useEffect)(() => {
    if (ref) {
      resetAnimation();
      document.addEventListener("keydown", onInteractionStart, { passive: true });
      document.addEventListener("keyup", onInteractionEnd, { passive: true });
      document.addEventListener("touchstart", onInteractionStart, { passive: true });
      document.addEventListener("touchend", onInteractionEnd, { passive: true });
      document.addEventListener("wheel", onInteraction, { passive: true });
      findSnapTarget();
      return () => {
        endAnimation();
        document.removeEventListener("keydown", onInteractionStart, { passive: true });
        document.removeEventListener("keyup", onInteractionEnd, { passive: true });
        document.removeEventListener("touchstart", onInteractionStart, { passive: true });
        document.removeEventListener("touchend", onInteractionEnd, { passive: true });
        document.removeEventListener("wheel", onInteraction, { passive: true });
      };
    }
  }, [
    ref,
    resetAnimation,
    findSnapTarget,
    endAnimation,
    onInteractionStart,
    onInteractionEnd,
    onInteraction
  ]);
  return scrollIndex;
}
var react_use_scroll_snap_default = useScrollSnap;
export {
  react_use_scroll_snap_default as default
};
//# sourceMappingURL=react-use-scroll-snap.js.map
